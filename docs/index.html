<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>react-native share</title>
    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/sky.css" id="theme">
    <!-- 自定义样式 -->
    <link rel="stylesheet" href="lib/css/myself.css">
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <!-- Printing and PDF exports -->
    <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);
    </script>
    <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>
    <div class="reveal">
        <!-- Any section element inside of this container is displayed as a slide -->
        <div class="slides">
            <section>
                <h2 id="title">react-native构建原生应用</h2>
                <!-- <p class="fragment" data-fragment-index="0" style="font-size: 24px;line-height: 40px;">程序猿也可以做一些美丽的事</p> -->
            </section>
            <section>
                <h3>目录</h3>
                <div style="width: 360px; margin: 0 auto; text-align: left;">
                    <p class="dot-left">什么是react-native</p>
                    <!--<p class="dot-left">搭建开发环境</p>-->
                    <p class="dot-left">实例演示</p>
                    <p class="dot-left">构建应用的技术栈</p>
                    <!--<p class="dot-left">一个简单的静态页面</p>  引入 简单的redux-->
                    <p class="dot-left">文件结构</p>
                    <!--<p class="dot-left">构建项目框架的思路</p>-->
                    <p class="dot-left">redux数据流</p>
                    <p class="dot-left">react的组件化思维</p>
                    <!--<p class="dot-left">构建原生应用</p>-->
                    <!--<p class="dot-left">react-native的利弊</p>-->
                </div>
            </section>
            <section>
                <section>
                    <h2>react-native</h2>
                    <!--TODO: 基于react构建手机应用的框架 封装了常用的手机端原生接口、组件-->
                </section>
                <section>
                    <p>基于react构建手机应用的框架</p>
                    <p>封装了常用的手机端原生接口、组件</p>
                </section>
                <section>
                    <h2>搭建开发环境</h2>
                    <p>http://facebook.github.io/react-native/docs</p>
                </section>
            </section>
            <section>
                <section>
                    <h2>实例演示</h2>
                    <!-- TODO: 登录登出数据流、hoc表单验证-->
                </section>
            </section>
            <section>
                <section>
                    <h2>构建应用的技术栈</h2>
                </section>
                <section style="top: 0;">
                    <img width="550" style="border: 0;margin: 0 10px;" data-src="./imgs/tech.png">
                </section>
            </section>
            <section>
                <section>
                    <h2>react</h2>
                    <img width="650" style="border: 0;margin: 0 10px;" data-src="./imgs/react.png">
                    <!--<p>看完整的例子</p>-->
                </section>
                <section>
                    <pre>
        <code  contenteditable style="max-height: 630px;">
            import React, { Component } from 'react';
            import {
                StyleSheet,
                View,
                Text,
                TouchableOpacity,
                Image,
                TextInput,
                PixelRatio,
            } from 'react-native';
            import Header from '../../common/Header';

            export default class LoginLayout extends Component {
                loginHandler = () => {
                }
                render() {
                    return (
                        <View style={styles.container}>
                            ...
                            <Text style={styles.name}>iuwei.</Text>
                            <TextInput
                                style={styles.input}
                                placeholder="用户名"
                                autoFocus
                                returnKeyType="next"
                                onSubmitEditing={() => {this.password.focus();}}
                            />
                            <TextInput
                                style={styles.input}
                                ref={(r) => {this.password = r;}}
                                placeholder="密码"
                                enablesReturnKeyAutomatically  //未输入时键盘的确定按钮不能点
                                returnKeyType="done"
                                blurOnSubmit   // 点击键盘的确定 收起键盘
                                onSubmitEditing={() => {this.loginHandler(); }}
                            />
                            <TouchableOpacity style={styles.btn} onPress={this.loginHandler}>
                            <Text style={styles.btnText}>登录</Text>
                            </TouchableOpacity>
                            <TouchableOpacity>
                            <Text style={styles.forget}>忘记密码?</Text>
                            </TouchableOpacity>
                        </View>
                    );
                }
            }

            const styles = StyleSheet.create({
                container: {
                    flex: 1,
                    paddingLeft: 20,
                    paddingRight: 20,
                    paddingTop: 100,
                },
                ...
            });
        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>redux</h2>
                    <img width="650" style="border: 0;margin: 0 10px;" data-src="./imgs/redux-flow.png">
                    <!-- store 只是包含一些方法的普通对象-->
                    <!-- 预设模式只有一个store： 数据变化特别频繁，应用特别庞大，redux只是其中的一个组件-->
                    <!-- TODO: middleware(例子、引入柯里化)-->
                    <p></p>
                </section>
                <section>
                    <pre>
                    <code contenteditable style="max-height: none;">
                    <!--component.js-->
                    dispatch(loginReduxAc({
                        username: this.username._lastNativeText
                        password: this.password._lastNativeText
                    }))

                    <!--action.js-->
                    export const loginReduxAc = data => action(USER, { ...data });

                    <!--action creator-->
                    export const action = (type, payload = {}) => {
                        return { type, ...payload };
                    };

                    <!-- reducer -->
                    (state = {islogin: false, info: {}}, action) => {
                        if (action.type === USER){
                            return {
                                isLogin: true,
                                info: {
                                    username: action.username,
                                }
                            }                  
                        }
                    }

                    <!-- store-->
                    store = createStore(reducer)
                    </code>
                    </pre>
                </section>
                
                <section>
                    <h2>middleware</h2>
                    <!--熟悉node express 的对middleware并不陌生： 接收请求到产生相应的过程， 本质是hack-->
                    <!-- 为什么要应用在createStore 上而不是store： 只应用middleware 一次-->
                    <!-- 为什么middleware要是链式的： 最初功能就是要作用在dispatch上， 大多数情况下我们需要为一个dispatch 注入多种mid 功能方法-->
                    <!--为什么要return dispatch 而不是直接赋值（next 和dispatch的区别）： 当在middleware 想再次dispatch 可以从头开始-->
                    <!--确定 Priovide 原理-->
                    <!--<p>applyMiddleware接收链式middleware</p>-->
                </section>
                <section>
                    <p>本质</p>
                    <pre>
                        <code contenteditable style="max-height: none;">
                        function m1(store){
                            const next = store.dispatch;
                            store.dispatch = function(action) {
                                console.log('m1 begin');
                                next(action);
                                console.log('m1 end');
                            }
                        }
                        function m2(store){
                            const next = store.dispatch;
                            store.dispatch = function(action) {
                                console.log('m2 begin');
                                next(action);
                                console.log('m2 end');
                            }
                        }
                        m1(store);
                        m2(store);
                        store.dispatch('EE');
                        </code>
                    </pre>
                </section>
                <section>
                    <img width="650" style="border: 0;margin: 0 10px;" data-src="./imgs/middleware-flow.png">
                    <p></p>
                </section>
                <section>
                    <pre>
                        <code contenteditable style="max-height: 630px;">
                        function n1(store){
                            return function(next){
                                return function(action) {
                                    console.log('n1 begin');
                                    next(action);
                                    console.log('n1 end');
                                }	
                            }
                        }
                        function n2(store){
                            return function(next){
                                return function(action) {
                                    console.log('n2 begin');
                                    next(action);
                                    console.log('n2 end');
                                }	
                            }	
                        }

                        function applyMiddlewareSimilar(store, middlewares) {
                            middlewares = middlewares.slice()
                            middlewares.reverse()

                            const dispatch = store.dispatch;
                            // 在每一个 middleware 中变换 dispatch 方法。
                            middlewares.forEach(middleware =>
                                dispatch = middleware(store)(dispatch);
                            )
                        }

                        applyMiddlewareSimilar(store, n1, n2)
                        store.dispatch('EE');
                        </code>
                    </pre>
                </section>
                <section>
                    <p>Q: next和store.dispatch的区别?</p>
                    <!--这也是 为什么在mid中是返回 dispatch 而不是给store.dispatch直接赋值的原因-->
                </section>
                <section>
                    <h2>柯里化</h2>
                    <pre>
                        <code contenteditable style="max-height: none;">
                        store => next => action => {
                            if(typeof action == 'function'){
                                action(store, next)
                            }else {
                                next(action)
                            }
                        }
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>补充一个API</h2>
                    <p>applyMiddleware: 接收链式middleware</p>
                    <p>applyMiddleware(thunk, logger)</p>
                </section>
                <section>
                    <p>本质</p>
                    <p>applyMiddleware = (...middleware) => (createStore) => (reducer, preloadedState, enhancer) {}</p>
                    <p>所以</p>
                    <p>applyMiddleware(thunk, logger)(createStore)(reducers)</p>
                </section>
                <section>
                    <h2>异步action</h2>
                    <p>request.js</p>
                </section>
                <section>
                    <pre>
        <code contenteditable style="max-height: 630px;">
            <!--action.js-->
            var newsList = ({newsId,url,page})=> {
                return {
                    types: [LOAD_NEWS_REQUEST,LOAD_NEWS_SUCCESS, LOAD_NEWS_FAILURE],
                    callAPI: () => fetch(`http://www.test.com/${url}&page=${page}`),
                    shouldCallAPI: (state) => {
                    const datas = state.newsList[newsId];
                    if (!datas) return true;
                    if (!!datas.isFetching) return false;
                    return true;
                    },
                    payload: {newsId,page}

                }
            }
            <!-- request.js-->
            module.exports = ({ dispatch, getState }) => next => action => {
                const {
                    types,
                    callAPI,
                    shouldCallAPI = () => true,
                    payload = {}
                } = action;

                if (!types) {
                    return next(action);
                }
                if (
                    !Array.isArray(types) ||
                    types.length !== 3 ||
                    !types.every(type => typeof type === 'string')
                ) {
                    throw new Error('Expected an array of three string types.');
                }

                if (typeof callAPI !== 'function') {
                    throw new Error('Expected fetch to be a function.');
                }
                if (!shouldCallAPI(getState())) {
                    return;
                }
                const [requestType, successType, failureType] = types;

                dispatch([{
                    ...payload,
                    type: requestType
                    }, networkIndicator(true)])

                return callAPI().then(
                    response => {
                        response.json().then(function(response){
                            if (!!payload.page) {
                            dispatch([{
                                ...payload,
                                type: successType,
                                response: response,
                                page: payload.page+1
                            },networkIndicator(false)]);
                            }else {
                            dispatch([{
                                ...payload,
                                type: successType,
                                response: response
                            },networkIndicator(false)]);
                            }
                        });
                    },
                    error => {
                        dispatch([{
                            ...payload,
                            type: failureType,
                            error: error,
                            supPayload
                        }, networkIndicator(false)]);
                    }
                );
            }
        </code>
                    </pre>
                    
                </section>
                <section>
                    <h2>优化</h2>
                    <p>service API集中处理</p>
                    <p>每个fetch请求的method、header可能不同</p>
                    <p>多个请求并行</p>
                    <p>多个请求链式</p>
                </section>
            </section>
            <!-------------------------------------------------------------------------->
            <section>
                <section>
                    <h2>sagas</h2>
                    <p>长事物模型，管理side-effects的途径</p>
                    <div  style="width: 560px; margin: 0 auto; text-align: left;">
                        <!--<p>side-effects</p>
                        <p>对acion dispach事件做出反应 </p>
                        <p>dispach新的actions</p>
                        <p>在没有action被dispath的情况下能够运用内部机制进行自我苏醒</p>-->
                    </div>
                </section>
                <section>
                    <h2>redux-saga</h2>
                    <p>saga是generator 函数</p>
                    <pre>
<code>
    function* loadLogin() {
        const params = yield select(getLoginInfo);
        yield call(fetchEntity, loginSagasAc, api.fetchLogin, params, function* (response) {
            yield put(user({ isLogin: true, info: response.data.info}));
            yield put(loginSagasAc.success());
        });
    }
</code>
                    </pre>
                </section>
                <section>
                    <p>做所有与state相关的异步操作, 保持视图和action creator 是纯函数</p>
                </section>
                <section>
                    <p>Q: side-effects 是什么？</p>
                    <!--一般函数是无状态的： 就像react的render函数一样，用户输入什么调用的时候就应该输出什么，并且不会影程序的其它部分，也就是我们说的 purefunction,但实际上我们很多函数会影响程序的状态，比如说一些异步操作，这些影响就叫做副作用-->
                </section>
            </section>
            <section>
                <section>
                    <h2>react-redux</h2>
                    <!--FIXME: 补充优化 -->
                    <p>HOC</p>
                    <p>Provide</p>
                    <p>Connect</p>
                </section>
            </section>
            <section>
                <section>
                    <h2>react-persist</h2>
                    <p>react-native: AsyncStorage</p>
                </section>
            </section>
            <section>
                <section>
                    <h2>文件结构</h2>
                    <p>记得截图</p>
                </section>
            </section>
            <section>
                <section>
                    <h2>redux数据流</h2>
                </section>
                <section>
                    <img width="650" style="border: 0;margin: 0 10px;" data-src="./imgs/login-store.png">
                </section>
                <section>
                  <pre>
<code  contenteditable style="max-height: 630px;">
<!--先注入redux-->
export default connect(
  (state) => {
    return {
      userData: state.account.user,
    };
  },
  (dispatch) => {
    return {
      loginReq: (obj) => {
        dispatch(loginSagasAc.request(obj));
      },
    };
  })(LoginSagas);
<!--onPress-->
loginHandler = () => {
this.props.loginReq({
    username: this.username._lastNativeText,
    password: this.password._lastNativeText
});
}
<!--监听数据变化-->
componentWillReceiveProps (nextProps) {
    const { loginData } = nextProps;
    if (this.props.loginData.isFetching && loginData.isFetching){
      if (loginData.status === 0){
        nextProps.userData.isLogin && this.props.navigator.push({
          name: 'TabsView',
          component: TabsView,
          params: {
            iTab: 1,
          }
        });
      } else if (loginData.status === -1){
        this.setState({
          error: '网络错误',
        });
      } else {
        this.setState({
          error: loginData.message,
        });
      }

    }
  }
<!--action.js-->
  export const loginSagasAc = {
	request: data => action(LOGINSAGAS.REQUEST, { ...data }),
	success: () => action(LOGINSAGAS.SUCCESS),
	failure: error => action(LOGINSAGAS.FAILURE, { error }),
};

<!--reducer.js-->
export default combineReducers({
	...
	login: commonRequest(LOGINSAGAS),
});
<!--sagas-->
function* loadLogin() {
	const params = yield select(getLoginInfo);
	yield call(fetchEntity, loginSagasAc, api.fetchLogin, params, function* (response) {
		yield put(user({ isLogin: true, info: response.data.info}));
		yield put(loginSagasAc.success());
	});
}

export default function* watchAccount() {
	yield takeLatest(LOGINSAGAS.REQUEST, loadLogin);
}
  </code>
                  </pre>
                </section>
                <section>
                    <img width="650" style="border: 0;margin: 0 10px;" data-src="./imgs/login-flow.png">
                </section>
            </section>

            <section>
                <section>

                    <h2>react的组件化思维之一HOC 或 原生相关 （选讲） </h2>
                    <!--<p>HOC</p>-->
                </section>
                <section>
                    <h2>需求</h2>
                    <div style="width: 400px; margin: 20px auto; text-align: left;">
                    <p>1. 实时验证</p>
                    <!--TODO: 显示哪个input的错误根据用户操作显示、加入后台的返回错误-->
                    <p>2. 自定义错误的显示</p>
                    <!--TODO:  phone、email、图片验证……-->
                    <p>3. 自定义配置表单验证</p>
                    </div>
                </section>
                <section>
                    <h2>redux-form</h2>
                    <p>reduxForm</p>
                    <p>field</p>
                </section>
            </section>

            <section>
                <section>
                    <h2>react-native的利弊</h2>
                </section>
                <section>
                    <div style="width: 800px; margin: 0 auto; text-align: left;">
                    <!--TODO: lineHeight 基准点不一样可能经常要借助 includeFontPadding: false ， textAlignVertical: 'top',或者直接不用这个属性。-->
                    <p>1. 布局的兼容性，特别是android端机型不同、分辨率不同</p>
                    <!--TODO: IOS和android上用的属性或API可能会不同：onkeypress、letterspace,如果一定要用，需要修改源码，并编译。有一些原生功能也可以查找第三方插件：camera、-->
                    <p>2. 对原生的API支持还有限</p> 
                    <p>3. 动画是略卡顿的，有些机型表现不一样，需要深入的优化。</p>
                    <!--TODO: ：打包、打包配置、写一些自定义的原生功能-->
                    <p>4. 还是需要掌握一些原生的东西</p>
                    </div>
                </section>
                <section>
                    <div style="width: 800px; margin: 0 auto; text-align: left;">
                    <p>1. 有JS的功底就可以写APP，而且可以兼容IOS、Android,很是酷炫。</p>
                    <p>2. 具有React的优势，数据驱动，高度组件化，很好的管理应用数据，性能好。</p>
                    <!--TODO: ：编写应用中遇到的问题，大多都可以到github、stackoverflow上找到解决方案，连一些原生的东西都很多-->
                    <p>3. 生态圈够大，维护者很多</p>
                    </div>
                </section>
            </section>

        </div>
    </div>
    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script>
    // More info https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        width: 1200,
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [{
            src: 'lib/js/classList.js',
            condition: function() {
                return !document.body.classList;
            }
        }, {
            src: 'plugin/markdown/marked.js',
            condition: function() {
                return !!document.querySelector('[data-markdown]');
            }
        }, {
            src: 'plugin/markdown/markdown.js',
            condition: function() {
                return !!document.querySelector('[data-markdown]');
            }
        }, {
            src: 'plugin/highlight/highlight.js',
            async: true,
            callback: function() {
                hljs.initHighlightingOnLoad();
            }
        }, {
            src: 'plugin/zoom-js/zoom.js',
            async: true
        }, {
            src: 'plugin/notes/notes.js',
            async: true
        }]
    });
    </script>
</body>

</html>
