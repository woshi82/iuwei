<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <title>react-native share</title>
    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/sky.css" id="theme">
    <!-- 自定义样式 -->
    <link rel="stylesheet" href="lib/css/myself.css">
    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <!-- Printing and PDF exports -->
    <script>
    var link = document.createElement('link');
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
    document.getElementsByTagName('head')[0].appendChild(link);
    </script>
    <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
</head>

<body>
    <div class="reveal">
        <!-- Any section element inside of this container is displayed as a slide -->
        <div class="slides">
            <section>
                <section>
                    <h2 id="title">用react-native构建原生应用</h2>
                </section>
                <section>
                    <p>Q: 前端领域，还有什么框架可以构建原生应用？</p>   
                    <!--weex ionic 性能 > 本质-->
                </section>
            </section>
            <section>
                <h3>目录</h3>
                <div style="width: 360px; margin: 0 auto; text-align: left;">
                    <p class="dot-left">什么是react-native</p>
                    <!--<p class="dot-left">搭建开发环境</p>-->
                    <p class="dot-left">实例演示</p>
                    <p class="dot-left">构建应用的技术栈</p>
                    <!--<p class="dot-left">一个简单的静态页面</p>  引入 简单的redux-->
                    <p class="dot-left">文件结构</p>
                    <!--<p class="dot-left">构建项目框架的思路</p>-->
                    <p class="dot-left">redux数据流</p>
                    <p class="dot-left">react的组件化思维</p>
                    <!--<p class="dot-left">构建原生应用</p>-->
                    <!--<p class="dot-left">react-native的利弊</p>-->
                </div>
            </section>
            <section>
                <section>
                    <h2>react-native</h2>
                    <!--TODO: 基于react构建手机应用的框架 封装了常用的手机端原生接口、组件-->
                </section>
                <section>
                    <p>基于react构建手机应用的框架</p>
                    <p>封装了常用的手机端原生接口、组件</p>
                </section>
                <section>
                    <h2>搭建开发环境</h2>
                    <p>http://facebook.github.io/react-native/docs</p>
                </section>
            </section>
            <section>
                <section>
                    <h2>实例演示</h2>
                    <!-- TODO: 登录登出数据流、hoc表单验证-->
                </section>
            </section>
            <section>
                <section>
                    <h2>构建应用的技术栈</h2>
                </section>
                <section style="top: 0;">
                    <img width="550" style="border: 0;margin: 0 10px;" data-src="./imgs/tech.png">
                </section>
            </section>
            <section>
                <section>
                    <h2>react</h2>
                    <img width="650" style="border: 0;margin: 0 10px;" data-src="./imgs/react.png">
                    <!--<p>react的是一个以数据驱动的框架，虽然声明式的渲染和至上而下的数据流相比传统模式下在性能和编码方面已经是一个很大的提升</p>-->
                </section>
                <section>
                    <img height="700" style="border: 0;margin: 0 10px;" data-src="./imgs/react1.png">
                </section>
                <section>
                    <p>state: this.state.btn</p>
                    <p>        this.btn</p>
                    <p>props: this.props.color </p>
                </section>
                <section>
                    <p>Q: 谈谈对前端MVVM的理解?</p>
                    <!--
                        首先v可以理解为最终在客户端呈现的界面
                        m 是扁平的js对象模型，react中的state最后都会存储在这么一个数据模型当中。
                        那对于视图到模型的事件监听， 数据模型到视图的数据绑定都会在VM中进行操作
                        我门都知道react中一个jsx 模版引擎，当数据变化的时候，在数据模型中会进行比如说diff操作、对象的observer等，来告诉模版引擎如何去编译数据模版,最后得到一个最终的string,呈现在用户视野中。
                        当然在每一个MVVM中都会有一套事件系统，它能够让我门在视图模版中进行一些事件监听，来监听一些用户操作之类的事件， 简单快速去响应数据变化。
                        所以mvvm是一种模型框架思维，在我们实际的编码的中，能够操作的是赋有vm一部分使命的一个一个的组件，所以组件化确实react开发中一个很重要的部分。
                        
                        当然在编码的细化当中也会有过滤器、helper 等等概念。
                    -->
                    
                </section>
                <section>
                    <h2>当页面变得复杂</h2>
                    <p>数据需要共享</p>
                    <p>页面逻辑复杂</p>
                    <p>多状态传递</p>
                    <p>后期维护一个文件？</p>
                </section>
            </section>
            <section>
                <section>
                    <h2>redux</h2>
                    <img width="650" style="border: 0;margin: 0 10px;" data-src="./imgs/redux-flow.png">
                    <!-- store 只是包含一些方法的普通对象-->
                    <!-- 预设模式只有一个store： 数据变化特别频繁，应用特别庞大，redux只是其中的一个组件-->
                    <!-- TODO: middleware(例子、引入柯里化)-->
                    <p></p>
                </section>
                <section>
                    <pre>
                    <code contenteditable style="max-height: none;">
                    <!--component.js-->
                    dispatch(loginReduxAc({
                        username: this.username._lastNativeText
                        password: this.password._lastNativeText
                    }))
                    <!--action.js-->
                    export const loginReduxAc = data => action(USER, { ...data });
                    <!--action creator-->
                    export const action = (type, payload = {}) => {
                        return { type, ...payload };
                    };
                    <!-- reducer -->
                    (state = {islogin: false, info: {}}, action) => {
                        if (action.type === USER){
                            return {
                                isLogin: true,
                                info: {
                                    username: action.username,
                                }
                            }                  
                        }
                    }
                    <!-- store-->
                    store = createStore(reducer)
                    </code>
                    </pre>
                </section>
                
                <section>
                    <h2>middleware</h2>
                    <!--熟悉node express 的对middleware并不陌生： 接收请求到产生相应的过程， 本质是hack-->
                    <!-- 为什么要应用在createStore 上而不是store： 只应用middleware 一次-->
                    <!-- 为什么middleware要是链式的： 最初功能就是要作用在dispatch上， 大多数情况下我们需要为一个dispatch 注入多种mid 功能方法-->
                    <!--为什么要return dispatch 而不是直接赋值（next 和dispatch的区别）： 当在middleware 想再次dispatch 可以从头开始-->
                    <!--确定 Priovide 原理-->
                    <!--<p>applyMiddleware接收链式middleware</p>-->
                </section>
                <section>
                    <p>本质</p>
                    <pre>
                        <code contenteditable style="max-height: none;">
                        function m1(store){
                            const next = store.dispatch;
                            store.dispatch = function(action) {
                                console.log('m1 begin');
                                next(action);
                                console.log('m1 end');
                            }
                        }
                        function m2(store){
                            const next = store.dispatch;
                            store.dispatch = function(action) {
                                console.log('m2 begin');
                                next(action);
                                console.log('m2 end');
                            }
                        }
                        m2(store);
                        m1(store);
                        store.dispatch('EE');

                        结果：
                        m1 begin > m2 begin > m1 end > m2 end
                        </code>
                    </pre>
                </section>
                <section>
                    <p>传统子例程的堆栈方式：后进先出</p>
                    <img width="650" style="border: 0;margin: 0 10px;" data-src="./imgs/middleware-flow.png">
                </section>
                <section>
                    <img height="650" style="border: 0;margin: 0 10px;" data-src="./imgs/mid1.png">
                    <!---->
                </section>
                <section>
                    <p>Q: next和store.dispatch的区别?</p>
                    <!--这也是 为什么在mid中是返回 dispatch 而不是给store.dispatch直接赋值的原因-->
                </section>
                <section>
                    <h2>柯里化</h2>
                    <pre>
                        <code contenteditable style="max-height: none;">
                        store => next => action => {
                            if(typeof action == 'function'){
                                action(store, next)
                            }else {
                                next(action)
                            }
                        }
                        </code>
                    </pre>
                </section>
                <section>
                    <h2>补充一个API</h2>
                    <p>applyMiddleware: 接收链式middleware</p>
                    <p>applyMiddleware(thunk, logger)</p>
                </section>
                <section>
                    <p>const store = createStore(reducers,{},enhancer);</p>
                    <p>本质</p>
                    <p>applyMiddleware = (...middleware) => (createStore) => (reducer, preloadedState, enhancer) {}</p>
                    <p>所以</p>
                    <p>applyMiddleware(thunk, logger)(createStore)(reducers)</p>
                </section>
                <section>
                    <h2>异步action</h2>
                    <p>request.js</p>
                </section>
                <section>
                    <img height="700" style="border: 0;margin: 0 10px;" data-src="./imgs/mid2.png"> 
                </section>
                <section>
                    <h2>优化</h2>
                    <p>service API集中处理</p>
                    <p>每个fetch请求的method、header可能不同</p>
                    <p>多个请求并行</p>
                    <p>多个请求链式</p>
                </section>
            </section>
            <!-------------------------------------------------------------------------->
            <section>
                <section>
                    <h2>sagas</h2>
                    <p>长事物模型，管理<span style="color: red">side-effects</span>的途径</p>
                     <!--系统中需要协程多个action和side-effects 可以理解成与系统交互的永久线程-->
                    <!--<div  style="width: 560px; margin: 0 auto; text-align: left;">-->
                        <!--<p>side-effects</p>
                        <p>对acion dispach事件做出反应 </p>
                        <p>dispach新的actions</p>
                        <p>在没有action被dispath的情况下能够运用内部机制进行自我苏醒</p>-->
                    <!--</div>-->
                </section>
                <section>
                     <div style="width: 560px; margin: 0 auto; text-align: left;">
                        <p>1. 对acion dispach事件做出反应 </p>
                        <p>2. dispach新的actions</p>
                        <p>3. 在没有action被dispath的情况下能够运用内部机制进行自我苏醒</p>
                     </div>
                </section>
                 <section>
                    <p>Q: side-effects 是什么？</p>
                    <!--一般函数是无状态的：xx 就像react的render函数一样xx, 用户输入什么调用的时候就应该输出什么，并且不会影程序的其它部分，也就是我们说的 purefunction,但实际上我们很多函数会影响程序的状态，比如说一些异步操作，这些影响就叫做副作用-->
                </section>
                <section>
                    <h2>redux-saga</h2>
                    <p>saga是generator 函数</p>
                    <!-- generator 是协程函数的一种，
                        协程：多个线程（单线程情况下就是多个函数）并行执行，只有一个线程处于执行状态，其它线程处于暂停态，线程之间可以交换执行权（一个线程执行到一半可以暂停执行，将执行权交给另一个线程，等稍后收回执行权的时候，再恢复执行）
                        协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行 -->
                    <pre>
<code>
    function* loadLogin() {
        const params = yield select(getLoginInfo);
        yield call(fetchEntity, loginSagasAc, api.fetchLogin, params, function* (response) {
            yield put(user({ isLogin: true, info: response.data.info}));
            yield put(loginSagasAc.success());
        });
    }

    var loadLoginHandler = loadLogin();
    loadLoginHandler.next();  // {value: xxx, done: false}
</code>
                    </pre>
                </section>
                <section>
                    <p>做所有与state相关的异步操作, 保持视图和action creator 是纯函数</p>
                </section>
               
            </section>
            <section>
                <section>
                    <h2>react-redux</h2>
                    <!--FIXME: 补充优化 -->
                    <p>HOC</p>
                    <p>Provide</p>
                    <p>Connect</p>
                </section>
                <section>
                        <pre>
                    <code style="max-height: none">
      <Provider store={this.state.store}>
        <App />
      </Provider>
      // LoginSagas.js
      connect(
        (state) => {
            const { account } = this,state;
            return {
            userData: account.user,
            loginData: account.login,
            };
        },
        (dispatch) => {
            return {
            loginReq: (obj) => {
                dispatch(loginSagasAc.request(obj));
            },
            };
        })(LoginSagas);
                    </code>
                        </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>react-persist</h2>
                    <p>react-native: AsyncStorage</p>
                </section>
                <!--存储并读取本地state的 reducer 操作-->
                <section>
                    <pre>
                        <code contenteditable style="max-height: none;">
const enhancer = compose(
  autoRehydrate(),
);
const store = createStore(
  reducers,
  {},
  enhancer,
);
export default configureStore(onComplete) {
  persistStore(store, { storage: AsyncStorage }, onComplete);

  if (isDebuggingInChrome) {
    window.store = store;
  }
  return store;
}
                        </code>
                    </pre>
                </section>
            </section>
            <section>
                <section>
                    <h2>文件结构</h2>
                </section>
                <section>
                    <img height="700" style="border: 0;margin: 0 10px;" data-src="./imgs/file.png">
                </section>
            </section>
            <section>
                <section>
                    <h2>redux数据流</h2>
                </section>
                <section>
                    <img width="650" style="border: 0;margin: 0 10px;" data-src="./imgs/login-store.png">
                </section>
                <section>
                  <pre>
<code  contenteditable style="max-height: 630px;">
<!--先注入redux-->
export default connect(
  (state) => {
    return {
      userData: state.account.user,
    };
  },
  (dispatch) => {
    return {
      loginReq: (obj) => {
        dispatch(loginSagasAc.request(obj));
      },
    };
  })(LoginSagas);
<!--onPress-->
loginHandler = () => {
this.props.loginReq({
    username: this.username._lastNativeText,
    password: this.password._lastNativeText
});
}
<!--监听数据变化-->
componentWillReceiveProps (nextProps) {
    const { loginData } = nextProps;
    if (this.props.loginData.isFetching && loginData.isFetching){
      if (loginData.status === 0){
        nextProps.userData.isLogin && this.props.navigator.push({
          name: 'TabsView',
          component: TabsView,
          params: {
            iTab: 1,
          }
        });
      } else if (loginData.status === -1){
        this.setState({
          error: '网络错误',
        });
      } else {
        this.setState({
          error: loginData.message,
        });
      }

    }
  }
<!--action.js-->
  export const loginSagasAc = {
	request: data => action(LOGINSAGAS.REQUEST, { ...data }),
	success: () => action(LOGINSAGAS.SUCCESS),
	failure: error => action(LOGINSAGAS.FAILURE, { error }),
};

<!--reducer.js-->
export default combineReducers({
	...
	login: commonRequest(LOGINSAGAS),
});
<!--sagas-->
function* loadLogin() {
	const params = yield select(getLoginInfo);
	yield call(fetchEntity, loginSagasAc, api.fetchLogin, params, function* (response) {
		yield put(user({ isLogin: true, info: response.data.info}));
		yield put(loginSagasAc.success());
	});
}

export default function* watchAccount() {
	yield takeLatest(LOGINSAGAS.REQUEST, loadLogin);
}
  </code>
                  </pre>
                </section>
                <section>
                    <img width="650" style="border: 0;margin: 0 10px;" data-src="./imgs/login-flow.png">
                </section>
            </section>

            <section>
                <section>
                    <h2>react的组件化思维之一: HOC</h2>
                    <!--<p>HOC</p>-->
                </section>
                <section>
                    <h2>组件化思维</h2>
                    <p>pure render component</p>
                    <p>HOC component</p>
                    <p>render logic</p>
                    <p>Context</p>
                    <p>Utility Methods</p>
                </section>
                <section>
                    <h2>表单验证需求</h2>
                    <div style="width: 400px; margin: 20px auto; text-align: left;">
                    <p>1. 实时验证</p>
                    <!--TODO: 显示哪个input的错误根据用户操作显示、加入后台的返回错误-->
                    <p>2. 自定义错误的显示</p>
                    <!--TODO:  phone、email、图片验证……-->
                    <p>3. 自定义配置表单验证</p>
                    </div>
                </section>
                <section>
                    <h2>功能</h2>
                    <div style="width: 400px; margin: 20px auto; text-align: left;">
                    <p>1. input事件监听</p>
                    <p>2. validate数据验证</p>
                    <p>3. 表单数据处理</p>
                    </div>
                </section>
                <section>
                    <p>react-native-gifted-form、react-native-clean-form...</p>
                    <p>mixins</p>
                    <p>es5</p>
                </section>
                <section>
                    <h2>redux-form</h2>
                    <p>reduxForm</p>
                    <p>field</p>
                </section>
                <section>
                    <img width="680" style="border: 0;margin: 0 10px;" data-src="./imgs/hoc1.png"/>
                </section>
                <section>
                    <img width="680" style="border: 0;margin: 0 10px;" data-src="./imgs/hoc2.png"/>
                </section>
                <section>
                    <img width="680" style="border: 0;margin: 0 10px;" data-src="./imgs/hoc3.png"/>
                </section>
                <section>
                    <img height="700" style="border: 0;margin: 0 10px;" data-src="./imgs/hoc4.png"/>
                </section>
                <section>
                    <img width="680" style="border: 0;margin: 0 10px;" data-src="./imgs/hoc5.png"/>
                </section>
                <section>
                    <h2>hoc</h2>
                    <img width="650" style="border: 0;margin: 0 10px;" data-src="./imgs/hoc-flow.png">
                </section>
            </section>
            <section>
                <section>
                    <div style="width: 400px; margin: 20px auto; text-align: left;">
                    <p>1、链接原生库</p>
                    <p>2、嵌入原生应用</p>
                    <p>3、打包</p>
                    <p>4、编译源码</p>
                    </div>
                </section>
            </section>
            <section>
                <section>
                    <h2>react-native的利弊</h2>
                </section>
                <section>
                    <div style="width: 800px; margin: 0 auto; text-align: left;">
                    <!--TODO: lineHeight 基准点不一样可能经常要借助 includeFontPadding: false ， textAlignVertical: 'top',或者直接不用这个属性。-->
                    <p>1. 布局的兼容性，特别是android端机型不同、分辨率不同</p>
                    <!--TODO: IOS和android上用的属性或API可能会不同：onkeypress、letterspace,如果一定要用，需要修改源码，并编译。有一些原生功能也可以查找第三方插件：camera、-->
                    <p>2. 对原生的API支持还有限</p> 
                    <p>3. 动画是略卡顿的，有些机型表现不一样，需要深入的优化。</p>
                    <!--TODO: ：打包、打包配置、写一些自定义的原生功能-->
                    <p>4. 还是需要掌握一些原生的东西</p>
                    </div>
                </section>
                <section>
                    <div style="width: 800px; margin: 0 auto; text-align: left;">
                    <p>1. 有JS的功底就可以写APP，而且可以兼容IOS、Android,很是酷炫。</p>
                    <p>2. 具有React的优势，数据驱动，高度组件化，很好的管理应用数据，性能好。</p>
                    <!--TODO: ：编写应用中遇到的问题，大多都可以到github、stackoverflow上找到解决方案，连一些原生的东西都很多-->
                    <p>3. 生态圈够大，维护者很多</p>
                    </div>
                </section>
            </section>

        </div>
    </div>
    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>
    <script>
    // More info https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        width: 1200,
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [{
            src: 'lib/js/classList.js',
            condition: function() {
                return !document.body.classList;
            }
        }, {
            src: 'plugin/markdown/marked.js',
            condition: function() {
                return !!document.querySelector('[data-markdown]');
            }
        }, {
            src: 'plugin/markdown/markdown.js',
            condition: function() {
                return !!document.querySelector('[data-markdown]');
            }
        }, {
            src: 'plugin/highlight/highlight.js',
            async: true,
            callback: function() {
                hljs.initHighlightingOnLoad();
            }
        }, {
            src: 'plugin/zoom-js/zoom.js',
            async: true
        }, {
            src: 'plugin/notes/notes.js',
            async: true
        }]
    });
    </script>
</body>

</html>
